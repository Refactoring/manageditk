/*=============================================================================

  NOTE: THIS FILE WAS AUTOMATICALLY GENERATED BY THE ManagedITK PROJECT.

  Project:   ManagedITK
  Program:   Insight Segmentation & Registration Toolkit
  Module:    itkManagedImage_@MANGLED_SUFFIX@.cxx
  Language:  C++/CLI
  Author:    Dan Mueller
  Date:      $Date: 2008-06-21 09:20:09 +0200 (Sat, 21 Jun 2008) $
  Revision:  $Revision: 18 $

  Portions of this code are covered under the ITK and VTK copyright.
  See http://www.itk.org/HTML/Copyright.htm for details.
  See http://www.vtk.org/copyright.php for details.

  Copyright (c) 2007-2008 Daniel Mueller

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
  
=============================================================================*/

#pragma once
#pragma warning( disable : 4635 ) // Disable warnings about XML doc comments
#pragma warning( disable : 4996 ) // Disable warnings about deprecated methods

#ifndef __itkManagedImage@MANGLED_SUFFIX@_cxx
#define __itkManagedImage@MANGLED_SUFFIX@_cxx

// Include some useful ITK headers
#pragma unmanaged
#include "itkImage.h"
#include "itkNumericTraits.h"
#include "itkImageFileReader.h"
#include "itkImageSeriesReader.h"
#include "itkImageFileWriter.h"
#include "itkImageSeriesWriter.h"
#include "itkGDCMImageIO.h"
#include "itkGDCMSeriesFileNames.h"

// Force managed
#pragma managed

// Use some managed namespaces
#using <mscorlib.dll>
#using <System.dll>
using namespace System;
using namespace System::IO;
using namespace System::Reflection;
using namespace System::Diagnostics;

// Include some useful ManagedITK files
#define IncludeManagedTypesFromSource
#include "itkManagedTypes.cxx"
#include "itkManagedObjectAutoPtr.cxx"
#define IncludeObjectCommandFromSource
#include "itkManagedObjectCommand.cxx"
#include "itkManagedImageBase.cxx"
#include "itkManagedExceptionObject.cxx"

namespace itk
{

///<summary>
///This class is a managed type instance wrapper for itk::Image. 
///</summary>
///<remarks>
///Images are defined by a pixel type (modeling the dependent variables),
///and a dimension (number of independent variables). 
///An image is modeled as an array, defined by a start index and a size.
///The underlying array can be accessed via the Buffer property.
///
///There are three sets of meta-data describing an image. These are "Region"
///objects that define a portion of an image via a starting index for the image
///array and a size. The ivar LargestPossibleRegion defines the size and
///starting index of the image dataset. The entire image dataset, however,
///need not be resident in memory. The region of the image that is resident in
///memory is defined by the "BufferedRegion". The Buffer is a contiguous block
///of memory.  The third set of meta-data defines a region of interest, called
///the "RequestedRegion". The RequestedRegion is used by the pipeline
///execution model to define what a filter is requested to produce.
///</remarks>
public ref class itkImage_@MANGLED_SUFFIX@ : itkImageBase
{

private:
    // NativeType
    typedef @IMAGE_TYPE@< @TEMPLATE_PARAMS@ > NativeType;
    itkObjectAutoPtr<NativeType> m_PointerToNative;
    
    // Private variables
    itkImageRegion^ m_Regions;

protected:
    ///<summary>Protected constructor.</summary>
    itkImage_@MANGLED_SUFFIX@ ( itkPixelType^ pixelType, unsigned int dim ) : itkImageBase()
    {
        this->m_PointerToNative.Reset();
        this->m_PixelType = pixelType;
        this->m_Dimension = dim;
    }

public:
    ///<summary>Dispose of the managed object.</summary>
    ~itkImage_@MANGLED_SUFFIX@ ( )
    {
        if (!this->IsDisposed)
        {
            this->m_IsDisposed = true;
            this->m_PointerToNative.Reset();
        }
    }

    ///<summary>Finalize the managed object.</summary>
    !itkImage_@MANGLED_SUFFIX@ ( )
    {
        if (!this->IsDisposed && this->DisposeNativeObjectOnFinalize)
            delete this;
    }

    ///<summary>Get the size of the image (from the LargestPossibleRegion).</summary>
    ///<remarks>This method was added in ManagedITK for simplicity.</remarks>
    property itkSize^ Size
    {
        virtual itkSize^ get() override
        {
            return itk::ManagedTypes::ToManagedSize<NativeType::ImageDimension>( m_PointerToNative->GetLargestPossibleRegion().GetSize() );
        }
    }

    ///<summary>Get/set the spacing between pixels of the image.</summary>
    property itkSpacing^ Spacing
    { 
        virtual itkSpacing^ get() override
        { return itk::ManagedTypes::ToManagedSpacing<NativeType::ImageDimension>( m_PointerToNative->GetSpacing() ); }
        virtual void set( itkSpacing^ spacing ) override
        { m_PointerToNative->SetSpacing( itk::ManagedTypes::ToNativeSpacing<NativeType::ImageDimension>(spacing) ); }
    }

    ///<summary>Get/set the origin of the image in physical space.</summary>
    property itkPoint^ Origin
    { 
        virtual itkPoint^ get() override
        { return itk::ManagedTypes::ToManagedPoint<NativeType::ImageDimension>( m_PointerToNative->GetOrigin() ); }
        virtual void set( itkPoint^ origin ) override
        { m_PointerToNative->SetOrigin( itk::ManagedTypes::ToNativePoint<NativeType::ImageDimension>(origin) ); }
    }

    ///<summary>
    ///Get/set the region object that defines the size and starting index
    ///for the largest possible region this image could represent.
    ///</summary>
    property itkImageRegion^ LargestPossibleRegion
    {
        virtual itkImageRegion^ get() override 
        { return itk::ManagedTypes::ToManagedImageRegion<NativeType::ImageDimension>( m_PointerToNative->GetLargestPossibleRegion() ); }
        virtual void set ( itkImageRegion^ region ) override 
        { this->m_PointerToNative->SetLargestPossibleRegion( itk::ManagedTypes::ToNativeImageRegion<NativeType::ImageDimension>(region) ); }
    }

    ///<summary>
    ///Get/set the region object that defines the size and starting index
    ///for the region of the image requested (i.e., the region of the
    ///image to be operated on by a filter). Setting the RequestedRegion
    ///does not cause the object to be modified.
    ///</summary>
    property itkImageRegion^ RequestedRegion
    {
        virtual itkImageRegion^ get() override
        { return itk::ManagedTypes::ToManagedImageRegion<NativeType::ImageDimension>( m_PointerToNative->GetRequestedRegion() ); }
        virtual void set ( itkImageRegion^ region ) override
        { this->m_PointerToNative->SetRequestedRegion( itk::ManagedTypes::ToNativeImageRegion<NativeType::ImageDimension>(region) ); }
    }
    
    ///<summary>
    ///Get/set the region object that defines the size and starting index
    ///of the region of the image currently loaded in memory.
    ///</summary>
    property itkImageRegion^ BufferedRegion
    {
        virtual itkImageRegion^ get() override
        { return itk::ManagedTypes::ToManagedImageRegion<NativeType::ImageDimension>( m_PointerToNative->GetBufferedRegion() ); }
        virtual void set ( itkImageRegion^ region ) override
        { this->m_PointerToNative->SetBufferedRegion( itk::ManagedTypes::ToNativeImageRegion<NativeType::ImageDimension>(region) ); }
    }

    ///<summary>Get the pointer to the underlying image data array.</summary>
    property IntPtr Buffer
    {
        virtual IntPtr get() override { return (IntPtr)m_PointerToNative->GetBufferPointer(); }
    }
    
    ///<summary>Get the direction cosines of the image. The direction cosines are vectors that point from one pixel to the next.</summary>
    property itkMatrix^ Direction 
    {
        virtual itkMatrix^ get() override
        { return itk::ManagedTypes::ToManagedMatrix<double, NativeType::ImageDimension, NativeType::ImageDimension>( m_PointerToNative->GetDirection() ); }
        virtual void set ( itkMatrix^ direction ) override
        { this->m_PointerToNative->SetDirection( itk::ManagedTypes::ToNativeMatrix<double, NativeType::ImageDimension, NativeType::ImageDimension>(direction) ); }
    }
    
    ///<summary>Get the last modified time.</summary>
    property unsigned long MTime 
    { 
        virtual unsigned long get() override { return this->m_PointerToNative->GetMTime(); }
    }

    ///<summary>Get a string representing the type instance of this INativePointer.</summary>
    ///<example>"IUC2", "IF3", "IVF22".</example>
    property String^ MangledTypeString
    {
        virtual String^ get() override { return "I@MANGLED_SUFFIX@"; }
    }
    
    ///<summary>
    ///Get/set the pointer to the native ITK object associated with
    ///this type instance.
    ///</summary>
    ///<returns>The pointer to the native ITK object.</returns>
    property virtual IntPtr NativePointer
    { 
        virtual IntPtr get() override
        {
            return IntPtr(this->m_PointerToNative.Get());
        }
        virtual void set ( IntPtr value) override
        {
            this->m_PointerToNative.Reset( (NativeType*)value.ToPointer() );
        }
    }

    ///<summary>Create an instance of the underlying native itk::Image.</summary>
    ///<remarks>
    ///Either Read(), Write(), or Allocate() must be called to
    ///populate the underlying native itk::Image.
    ///</remarks>
    static itkImage_@MANGLED_SUFFIX@^ New (  )
    {
        itkPixelType^ pixelType = itkPixelType::@MANGLED_PIXEL@;
        const unsigned int dim = NativeType::ImageDimension;
        itkImage_@MANGLED_SUFFIX@^ image = gcnew itkImage_@MANGLED_SUFFIX@( pixelType, dim );
        return image;
    }

    ///<summary>Return itk::LightObject::Print( ostream ) as a string.</summary>
    virtual String^ ToString ( ) override
    {
        std::stringstream ss;
        m_PointerToNative->Print( ss );
        std::string s = ss.str();
        return gcnew String( s.c_str() );
    }

    ///<summary>
    ///Remove all observers watching this object.
    ///</summary>
    ///<remarks>
    ///By default, observers are created for all events. Calling this
    ///method removes all native observers, and therefore prevents
    ///the firing of managed events. Call AddAnyEventObserver() to
    ///reset the default observers which enable the managed events.
    ///</remarks>
    virtual void RemoveAllObservers ( ) override
    {
        this->m_PointerToNative->RemoveAllObservers();
    }

    ///<summary>
    ///Adds a native observer watching for any event.
    ///</summary>
    ///<remarks>
    ///By default, observers are created for all events. Calling this
    ///method adds a single native observer for any event. This
    ///observer invokes the managed events. Therefore, calling this
    ///method more than once, or calling it without first calling
    ///RemoveAllObservers(), may cause the managed events to be
    ///invoked more than once.
    ///</remarks>
    virtual void AddAnyEventObserver ( ) override
    {
        itk::itkObjectCommand::Pointer observer = itk::itkObjectCommand::New();
        observer->SetManagedObject( this );
        this->m_PointerToNative->AddObserver( itk::AnyEvent(), observer );
    }

    ///<summary>Read the image from the given file.</summary>
    ///<param name="filename">The relative or absolute file path and name.</param>
    ///<remarks>This method finalises the creation of the underlying native itk::Image.</remarks>
    virtual void Read ( System::String^ filename ) override
    {
        try
        {
            // Set filename
            this->Name = filename;

            // Marshal string to std::string
            std::string stdFilename;
            itkObject::MarshalString( filename, stdFilename );

            // Read the image
            typedef itk::ImageFileReader< NativeType > ReaderType;
            ReaderType::Pointer reader = ReaderType::New();
            reader->SetFileName( stdFilename.c_str() );
            reader->Update();
            
            // Save the reference
            this->m_PointerToNative.Reset( reader->GetOutput() );

            // Add AnyEvent observer
            this->AddAnyEventObserver();
        }
        catch ( itk::ExceptionObject& ex )
        {
            throw gcnew itkExceptionObject( ex );
        }
        catch ( Exception^ ex )
        {
            System::String^ message = "Unable to read '" + System::IO::Path::GetFileName(filename) + "'.";
            throw gcnew ApplicationException(message, ex);
        }	
    }
    
    ///<summary>Read an image series from the given filenames.</summary>
    ///<param name="filenames">An array of absolute file paths.</param>
    ///<remarks>This method finalises the creation of the underlying native itk::Image.</remarks>
    virtual void ReadSeries ( array<System::String^>^ filenames ) override
    {
        try
        {
            // Check we have some filenames
            if (filenames == nullptr || filenames->Length == 0)
            {
                System::String^ message = "No filenames were given. One or more filenames must be specified for the series.";
                throw gcnew ApplicationException(message);
            }
            
            // Check that dimensions is greater than 2
            if (NativeType::ImageDimension <= 2)
            {
                System::String^ message = "The image type must have three (3) or more dimensions.";
                throw gcnew ApplicationException(message);
            }

            // Setup the reader
            typedef itk::ImageSeriesReader< NativeType > ReaderType;
            ReaderType::Pointer reader = ReaderType::New();

            // Enumerate the filenames
            for each (System::String^ filename in filenames)
            {
                // Add the filename
                std::string stdFilename;
                itkObject::MarshalString( filename, stdFilename );
                reader->AddFileName( stdFilename.c_str() );
            }
            
            // Read the series
            reader->Update();
            
            // Save the reference
            m_PointerToNative.Reset( reader->GetOutput() );

            // Add AnyEvent observer
            this->AddAnyEventObserver();
        }
        catch ( itk::ExceptionObject& ex )
        {
            throw gcnew itkExceptionObject( ex );
        }
        catch ( Exception^ ex )
        {
            System::String^ message = "Unable to read series.";
            throw gcnew ApplicationException(message, ex);
        }
    }

    ///<summary>
    ///Read an image from the given DICOM directory using GDCM.
    ///This method uses the first found series identifier.
    ///</summary>
    ///<param name="directory">The directory containing the DICOM series.</param>
    ///<remarks>This method was added in ManagedITK for simplicity.</remarks>
    virtual void ReadDicomDirectory( System::String^ directory ) override
    {
        this->ReadDicomDirectory(directory, nullptr, nullptr);
    }
    
    ///<summary>Read an image from the given DICOM directory using GDCM.</summary>
    ///<param name="directory">The directory containing the DICOM series.</param>
    ///<param name="seriesid">The identifier of the series to read. If the given seriesid is empty, the first found identifier is used.</param>
    ///<remarks>This method was added in ManagedITK for simplicity.</remarks>
    virtual void ReadDicomDirectory( System::String^ directory, System::String^ seriesid ) override
    {
        this->ReadDicomDirectory(directory, seriesid, nullptr);
    }
    
    ///<summary>Read an image from the given DICOM directory using GDCM.</summary>
    ///<param name="directory">The directory containing the DICOM series.</param>
    ///<param name="seriesid">The identifier of the series to read.</param>
    ///<param name="restrictions">Specifies additional DICOM information to distinguish unique volumes within the directory. Eg. "0008|0021" distinguishes series based on date.</param>
    ///<remarks>This method was added in ManagedITK for simplicity.</remarks>
    virtual void ReadDicomDirectory( System::String^ directory, 
                                     System::String^ seriesid,
                                     ... array<System::String^>^ restrictions) override
    {
        try
        {
            // Ensure the directory exists
            if ( directory == nullptr || directory->Length == 0 || !Directory::Exists(directory) )
                throw gcnew DirectoryNotFoundException("The specified DICOM directory could not be found: " + directory);

            // Set name
            this->Name = directory;

            // Setup the reader
            typedef itk::ImageSeriesReader< NativeType > ReaderType;
            typedef itk::GDCMImageIO ImageIOType;
            ImageIOType::Pointer dicomIO = ImageIOType::New();
            ReaderType::Pointer reader = ReaderType::New();
            reader->SetImageIO( dicomIO );

            // Setup the series file name generator, and use restrictions
            typedef itk::GDCMSeriesFileNames NamesGeneratorType;
            NamesGeneratorType::Pointer nameGenerator = NamesGeneratorType::New();

            if ( restrictions != nullptr && restrictions->Length > 0 )
            {
                nameGenerator->SetUseSeriesDetails( true );
                for each ( String^ restriction in restrictions )
                {
                    std::string stdRestriction;
                    itkObject::MarshalString(restriction, stdRestriction);
                    nameGenerator->AddSeriesRestriction( stdRestriction.c_str() );
                }
            }
            std::string stdDirectory;
            itkObject::MarshalString( directory, stdDirectory );
            nameGenerator->SetDirectory( stdDirectory.c_str() );

            // Get a default series identifier if not supplied
            std::string stdSeriesId;
            if (seriesid == nullptr || seriesid->Length == 0)
            {
                typedef std::vector< std::string > SeriesIdContainer;
                const SeriesIdContainer& seriesUID = nameGenerator->GetSeriesUIDs();
                stdSeriesId = seriesUID.begin()->c_str();
            }
            else
            {
                itkObject::MarshalString( seriesid, stdSeriesId );
            }

            // Get the file names
            typedef std::vector< std::string > FileNamesContainer;
            FileNamesContainer fileNames = nameGenerator->GetFileNames( stdSeriesId );
            reader->SetFileNames( fileNames );

            // Perform the reading
            reader->Update();

            // Save the reference
            m_PointerToNative.Reset( reader->GetOutput() );

            // Add AnyEvent observer
            this->AddAnyEventObserver();
        }
        catch ( itk::ExceptionObject& ex )
        {
            throw gcnew itkExceptionObject( ex );
        }
        catch ( Exception^ ex )
        {
            System::String^ message = "Unable to read DICOM directory.";
            throw gcnew ApplicationException(message, ex);
        }
    }

    ///<summary>Write the image to the given file.</summary>
    ///<param name="filename">The relative or absolute file path and name.</param>
    ///<remarks>This method finalises the creation of the underlying native itk::Image.</remarks>
    virtual void Write ( System::String^ filename ) override
    {
        try
        {
            // Marshal string to std::string
            std::string stdFilename;
            itkObject::MarshalString( filename, stdFilename );

            // Write the image
            typedef itk::ImageFileWriter< NativeType > WriterType;
            WriterType:: Pointer writer = WriterType::New();
            writer->SetFileName( stdFilename.c_str() );
            writer->SetInput( m_PointerToNative.Get() );
            writer->Update();
        }
        catch ( itk::ExceptionObject& ex )
        {
            throw gcnew itkExceptionObject( ex );
        }
        catch ( Exception^ ex )
        {
            System::String^ message = "Unable to write '" + System::IO::Path::GetFileName(filename) + "'.";
            throw gcnew ApplicationException(message, ex);
        }
    }
    
    ///<summary>Write an image series to the files matching the given format.</summary>
    ///<param name="filenameFormat">The absolute path and filename format for the images. Eg. C:/temp/test_{0}.png.</param>
    ///<param name="seriesFormat">A format string for the series numbers. Eg. "000".</param>
    ///<example>filenameFormat="C:/temp/test_{0}.png" and seriesFormat="000".</example>
    ///<remarks>This method was added in ManagedITK for simplicity.</remarks>
    virtual void WriteSeries ( System::String^ filenameFormat, System::String^ seriesFormat ) override
    {
        try
        {
            // Check we have a filenameFormat
            if (filenameFormat == nullptr || filenameFormat->Length == 0)
            {
                System::String^ message = "No filenameFormat was given. A valid absolute path and filename pattern must specified for the series.";
                throw gcnew ApplicationException(message);
            }

            // Check that dimensions is 3
            if (NativeType::ImageDimension != 3)
            {
                System::String^ message = "The image type must have three (3) dimensions.";
                throw gcnew ApplicationException(message);
            }

            // Setup the writer
            typedef itk::Image< NativeType::PixelType, 2 > OutputType;
            typedef itk::ImageSeriesWriter< NativeType, OutputType > WriterType;
            WriterType::Pointer writer = WriterType::New();
            writer->SetInput( this->m_PointerToNative.Get() );

            // Enumerate the filenames
            for (unsigned int i=0; i<this->Size[2]; i++)
            {
                // Format the string
                System::String^ filename = String::Format( filenameFormat, i.ToString(seriesFormat) );

                // Add the filename
                std::string stdFilename;
                itkObject::MarshalString( filename, stdFilename );
                writer->AddFileName( stdFilename.c_str() );
            }

            // Write the series
            writer->Update();
        }
        catch ( itk::ExceptionObject& ex )
        {
            throw gcnew itkExceptionObject( ex );
        }
        catch ( Exception^ ex )
        {
            System::String^ message = "Unable to write series.";
            throw gcnew ApplicationException(message, ex);
        }
    }

    ///<summary>
    ///Allocates the memory for an empty image.
    ///This is the method to use to create an image from scratch (ie. not from IO).
    ///The regions MUST have been set: call SetRegions() before calling this method.
    ///The buffer is NOT initialised: call FillBuffer() after calling this method.
    ///</summary>
    ///<remarks>This method finalises the creation of the underlying native itk::Image.</remarks>
    virtual void Allocate ( ) override
    {
        try
        {
            // Create new native itk::Image
            NativeType::Pointer newImagePtr = NativeType::New();
            this->m_PointerToNative.Reset( newImagePtr );
            
            // Add AnyEvent observer
            this->AddAnyEventObserver();

            // Set the regions
            if ( this->m_Regions != nullptr )
                this->m_PointerToNative->SetRegions( itk::ManagedTypes::ToNativeImageRegion<NativeType::ImageDimension>(this->m_Regions) );
    
            // Allocate the memory
            this->m_PointerToNative->Allocate( );
        }
        catch ( itk::ExceptionObject& ex )
        {
            throw gcnew itkExceptionObject( ex );
        }
    }

    ///<summary>
    ///Convenience method to set the LargestPossibleRegion, BufferedRegion and RequestedRegion.
    ///</summary>
    ///<param name="regions">The image region specifying the largest, requested, and buffered size.</param>
    ///<remarks>
    ///This method does not allocate the image, use Allocate for that purpose.
    ///</remarks>
    virtual void SetRegions ( itkImageRegion^ regions ) override
    {
        try
        {
            // Save the regions for later use with Allocate()
            this->m_Regions = regions;
    
            // If the native image has been allocated, set the regions
            if ( this->m_PointerToNative.Get() != 0 )
                this->m_PointerToNative->SetRegions( itk::ManagedTypes::ToNativeImageRegion<NativeType::ImageDimension>(regions) );
        }
        catch ( itk::ExceptionObject& ex )
        {
            throw gcnew itkExceptionObject( ex );
        }
    }

    ///<summary>
    ///Fills the image data with the given value.
    ///The image regions must be set before calling this method and
    ///the image must have been allocated.
    ///</summary>
    ///<param name="value">The pixel value to fill the image.</param>
    virtual void FillBuffer ( itkPixel^ value ) override
    {
        try
        {
            this->m_PointerToNative->FillBuffer( itk::ManagedTypes::ToNativePixel<NativeType::PixelType>(value) );
        }
        catch ( itk::ExceptionObject& ex )
        {
            throw gcnew itkExceptionObject( ex );
        }
    }
    
    ///<summary>Returns the pixel value at the given discrete location.</summary>
    ///<param name="index">The discrete location in image space.</param>
    ///<returns>The pixel value at the given discrete location.</returns>
    virtual itkPixel^ GetPixel ( itkIndex^ index ) override
    {
        NativeType::IndexType indexUnmanaged = itk::ManagedTypes::ToNativeIndex<NativeType::ImageDimension>(index);
        return itk::ManagedTypes::ToManagedPixel<NativeType::PixelType>( m_PointerToNative->GetPixel(indexUnmanaged) );
    }

    ///<summary>Set the pixel value at the given discrete location.</summary>
    ///<param name="index">The discrete location in image space.</param>
    ///<param name="value">The new value to set.</param>
    virtual void SetPixel ( itkIndex^ index, itkPixel^ value ) override
    {
        NativeType::IndexType indexUnmanaged = itk::ManagedTypes::ToNativeIndex<NativeType::ImageDimension>(index);
        this->m_PointerToNative->SetPixel( indexUnmanaged, itk::ManagedTypes::ToNativePixel<NativeType::PixelType>(value) );
    }
    
    ///<summary>Separate this image from the pipeline.</summary>
    ///<remarks>
    ///This method disconnects the image from the upstream pipeline.
    ///Hence an Update() from downstream will not propagate back past this image.
    ///To completely isolate this image from the pipeline, the application must
    ///remove this image from any filters which it is connected as the input.
    ///</remarks>
    virtual void DisconnectPipeline ( ) override
    {
        try
        {
            this->m_PointerToNative->DisconnectPipeline();
        }
        catch ( itk::ExceptionObject& ex )
        {
            throw gcnew itkExceptionObject( ex );
        }
    }

    ///<summary>Convert a physical point to a continuous index.</summary>
    ///<param name="point">The geometric location in physical space.</param>
    ///<param name="cindex">The resultant continuous location in image space.</param>
    ///<returns>true if the resulting index is within the image, false otherwise.</returns>
    virtual bool TransformPhysicalPointToContinuousIndex( itkPoint^ point, [System::Runtime::InteropServices::Out] itkContinuousIndex^% cindex ) override
    {
        try
        {
            NativeType::PointType pointUnmanaged = itk::ManagedTypes::ToNativePoint<NativeType::ImageDimension>(point);
            itk::ContinuousIndex<double, NativeType::ImageDimension> cindexUnmanaged;
            bool result = this->m_PointerToNative->TransformPhysicalPointToContinuousIndex(pointUnmanaged, cindexUnmanaged);
            cindex = itk::ManagedTypes::ToManagedContinuousIndex(cindexUnmanaged);
            return result;
        }
        catch ( itk::ExceptionObject& ex )
        {
            throw gcnew itkExceptionObject( ex );
        }
    }
    
    ///<summary>Convert a physical point to a discrete index.</summary>
    ///<param name="point">The geometric location in physical space.</param>
    ///<param name="index">The resultant discrete location in image space.</param>
    ///<returns>true if the resulting index is within the image, false otherwise.</returns>
    virtual bool TransformPhysicalPointToIndex( itkPoint^ point, [System::Runtime::InteropServices::Out] itkIndex^% index ) override
    {
        try
        {
            NativeType::PointType pointUnmanaged = itk::ManagedTypes::ToNativePoint<NativeType::ImageDimension>(point);
            NativeType::IndexType indexUnmanaged;
            bool result = this->m_PointerToNative->TransformPhysicalPointToIndex(pointUnmanaged, indexUnmanaged);
            index = itk::ManagedTypes::ToManagedIndex(indexUnmanaged);
            return result;
        }
        catch ( itk::ExceptionObject& ex )
        {
            throw gcnew itkExceptionObject( ex );
        }
    }

    ///<summary>Convert a continuous index to a physical point.</summary>
    ///<param name="cindex">The continuous location in image space.</param>
    ///<param name="point">The resultant geometric location in physical space.</param>
    virtual void TransformContinuousIndexToPhysicalPoint( itkContinuousIndex^ cindex, [System::Runtime::InteropServices::Out] itkPoint^% point ) override
    {
        try
        {
            itk::ContinuousIndex<double, NativeType::ImageDimension> cindexUnmanaged = itk::ManagedTypes::ToNativeContinuousIndex<NativeType::ImageDimension>(cindex);
            NativeType::PointType pointUnmanaged;
            this->m_PointerToNative->TransformContinuousIndexToPhysicalPoint(cindexUnmanaged, pointUnmanaged);
            point = itk::ManagedTypes::ToManagedPoint(pointUnmanaged);
        }
        catch ( itk::ExceptionObject& ex )
        {
            throw gcnew itkExceptionObject( ex );
        }
    }

    ///<summary>Convert a discrete index to a physical point.</summary>
    ///<param name="index">The discrete location in image space.</param>
    ///<param name="point">The resultant geometric location in physical space.</param>
    virtual void TransformIndexToPhysicalPoint( itkIndex^ index, [System::Runtime::InteropServices::Out] itkPoint^% point ) override
    {
        try
        {
            NativeType::IndexType indexUnmanaged = itk::ManagedTypes::ToNativeIndex<NativeType::ImageDimension>(index);
            NativeType::PointType pointUnmanaged;
            this->m_PointerToNative->TransformIndexToPhysicalPoint(indexUnmanaged, pointUnmanaged);
            point = itk::ManagedTypes::ToManagedPoint(pointUnmanaged);
        }
        catch ( itk::ExceptionObject& ex )
        {
            throw gcnew itkExceptionObject( ex );
        }
    }

}; // end ref class

} // end namespace itk

#endif
