WRAP_CLASS("itk::AffineTransform")

  SET(MANAGED_TYPE_TEMPLATE ${MANAGED_ITK_SOURCE_COMMON_PATH}/itkManagedMatrixOffsetTransform_TYPE.cxx.in)
  SET(MANAGED_WRAPPER_TEMPLATE ${MANAGED_ITK_SOURCE_COMMON_PATH}/itkManagedMatrixOffsetTransform_WRAPPER.cxx.in)

  FOREACH(d ${WRAP_ITK_DIMS})
    WRAP_TEMPLATE("${ITKM_D}${d}" "${ITKT_D},${d}")
  ENDFOREACH(d)

  BEGIN_MANAGED_METHOD("Translate")
    SET(MANAGED_METHOD_SUMMARY         "This method modifies self to include a translation of the origin. The translation is precomposed with self if pre is true, and postcomposed otherwise.")
    SET(MANAGED_METHOD_RETURN_TYPE     "void")
    SET(MANAGED_METHOD_PARAMS          "itkVector^ offset, bool pre")
    SET(MANAGED_METHOD_TYPE_BODY       "m_PointerToNative->Translate( itk::ManagedTypes::ToNativeVector<OutputVectorType::Dimension>(offset), pre );")
    SET(MANAGED_METHOD_WRAPPER_BODY    "iInstance->Translate( offset, pre );")
  END_MANAGED_METHOD()
  
  BEGIN_MANAGED_METHOD("Translate")
    SET(MANAGED_METHOD_SUMMARY         "This method modifies self to include a translation of the origin. The translation is postcomposed.")
    SET(MANAGED_METHOD_RETURN_TYPE     "void")
    SET(MANAGED_METHOD_PARAMS          "itkVector^ offset")
    SET(MANAGED_METHOD_TYPE_BODY       "this->Translate( offset, false );")
    SET(MANAGED_METHOD_WRAPPER_BODY    "iInstance->Translate( offset, false );")
  END_MANAGED_METHOD()

  BEGIN_MANAGED_METHOD("Scale")
    SET(MANAGED_METHOD_SUMMARY         "This method modifies self to magnify the source by a given factor along each axis. If all factors are the same, then the scaling is isotropic; otherwise it is anisotropic. The scaling is precomposed with self if pre is true, and postcomposed otherwise.")
    SET(MANAGED_METHOD_RETURN_TYPE     "void")
    SET(MANAGED_METHOD_PARAMS          "itkVector^ factor, bool pre")
    SET(MANAGED_METHOD_TYPE_BODY       "m_PointerToNative->Scale( itk::ManagedTypes::ToNativeVector<OutputVectorType::Dimension>(factor), pre );")
    SET(MANAGED_METHOD_WRAPPER_BODY    "iInstance->Scale( factor, pre );")
  END_MANAGED_METHOD()
  
  BEGIN_MANAGED_METHOD("Scale")
    SET(MANAGED_METHOD_SUMMARY         "This method modifies self to magnify the source by a given factor along each axis. If all factors are the same, then the scaling is isotropic; otherwise it is anisotropic. The scaling is postcomposed.")
    SET(MANAGED_METHOD_RETURN_TYPE     "void")
    SET(MANAGED_METHOD_PARAMS          "itkVector^ factor")
    SET(MANAGED_METHOD_TYPE_BODY       "this->Scale( factor, false );")
    SET(MANAGED_METHOD_WRAPPER_BODY    "iInstance->Scale( factor, false );")
  END_MANAGED_METHOD()

  BEGIN_MANAGED_METHOD("Scale")
    SET(MANAGED_METHOD_SUMMARY         "This method modifies self to magnify the source by a given factor along each axis. Seeing all factors are the same, the scaling is isotropic. The scaling is precomposed with self if pre is true, and postcomposed otherwise.")
    SET(MANAGED_METHOD_RETURN_TYPE     "void")
    SET(MANAGED_METHOD_PARAMS          "double factor, bool pre")
    SET(MANAGED_METHOD_TYPE_BODY       "m_PointerToNative->Scale( static_cast<ScalarType>(factor), pre );")
    SET(MANAGED_METHOD_WRAPPER_BODY    "iInstance->Scale( factor, pre );")
  END_MANAGED_METHOD()
  
  BEGIN_MANAGED_METHOD("Scale")
    SET(MANAGED_METHOD_SUMMARY         "This method modifies self to magnify the source by a given factor along each axis. Seeing all factors are the same, the scaling is isotropic. The scaling is postcomposed.")
    SET(MANAGED_METHOD_RETURN_TYPE     "void")
    SET(MANAGED_METHOD_PARAMS          "double factor")
    SET(MANAGED_METHOD_TYPE_BODY       "this->Scale( factor, false );")
    SET(MANAGED_METHOD_WRAPPER_BODY    "iInstance->Scale( factor, false );")
  END_MANAGED_METHOD()

  BEGIN_MANAGED_METHOD("Rotate")
    SET(MANAGED_METHOD_SUMMARY         "This method composes self with a rotation that affects two specified axes, replacing the current value of self. The rotation angle is in radians. The axis of rotation goes through the origin. The rotation is precomposed with self if pre is true, and postcomposed otherwise.")
    SET(MANAGED_METHOD_RETURN_TYPE     "void")
    SET(MANAGED_METHOD_PARAMS          "int axis1, int axis2, double angle, bool pre")
    SET(MANAGED_METHOD_TYPE_BODY       "m_PointerToNative->Rotate( axis1, axis2, static_cast<ScalarType>(angle), pre );")
    SET(MANAGED_METHOD_WRAPPER_BODY    "iInstance->Rotate( axis1, axis2, angle, pre );")
  END_MANAGED_METHOD()

  BEGIN_MANAGED_METHOD("Rotate")
    SET(MANAGED_METHOD_SUMMARY         "This method composes self with a rotation that affects two specified axes, replacing the current value of self. The rotation angle is in radians. The axis of rotation goes through the origin. The rotation is postcomposed.")
    SET(MANAGED_METHOD_RETURN_TYPE     "void")
    SET(MANAGED_METHOD_PARAMS          "int axis1, int axis2, double angle")
    SET(MANAGED_METHOD_TYPE_BODY       "this->Rotate( axis1, axis2, angle, false );")
    SET(MANAGED_METHOD_WRAPPER_BODY    "iInstance->Rotate( axis1, axis2, angle, false );")
  END_MANAGED_METHOD()

  BEGIN_MANAGED_METHOD("Rotate2D")
    SET(MANAGED_METHOD_SUMMARY         "This method composes self, which must be a 2D affine transformation, with a clockwise rotation through a given angle in radians. The center of rotation is the origin. The rotation is precomposed with self if pre is true, and postcomposed otherwise.")
    SET(MANAGED_METHOD_RETURN_TYPE     "void")
    SET(MANAGED_METHOD_PARAMS          "double angle, bool pre")
    SET(MANAGED_METHOD_TYPE_BODY       "m_PointerToNative->Rotate2D( static_cast<ScalarType>(angle), pre );")
    SET(MANAGED_METHOD_WRAPPER_BODY    "iInstance->Rotate2D( angle, pre );")
  END_MANAGED_METHOD()
  
  BEGIN_MANAGED_METHOD("Rotate2D")
    SET(MANAGED_METHOD_SUMMARY         "This method composes self, which must be a 2D affine transformation, with a clockwise rotation through a given angle in radians. The center of rotation is the origin. The rotation is postcomposed.")
    SET(MANAGED_METHOD_RETURN_TYPE     "void")
    SET(MANAGED_METHOD_PARAMS          "double angle")
    SET(MANAGED_METHOD_TYPE_BODY       "this->Rotate2D( angle, false );")
    SET(MANAGED_METHOD_WRAPPER_BODY    "iInstance->Rotate2D( angle, false );")
  END_MANAGED_METHOD()

  BEGIN_MANAGED_METHOD("Rotate3D")
    SET(MANAGED_METHOD_SUMMARY         "This method composes self, which must be a 3D affine transformation, with a clockwise rotation around a specified axis. The rotation angle is in radians; the axis of rotation goes through the origin. The rotation is precomposed with self if pre is true, and postcomposed otherwise.")
    SET(MANAGED_METHOD_RETURN_TYPE     "void")
    SET(MANAGED_METHOD_PARAMS          "itkVector^ axis, double angle, bool pre")
    SET(MANAGED_METHOD_TYPE_BODY       "m_PointerToNative->Rotate3D( itk::ManagedTypes::ToNativeVector<OutputVectorType::Dimension>(axis), static_cast<ScalarType>(angle),  pre );")
    SET(MANAGED_METHOD_WRAPPER_BODY    "iInstance->Rotate3D( axis, angle, pre );")
  END_MANAGED_METHOD()
  
  BEGIN_MANAGED_METHOD("Rotate3D")
    SET(MANAGED_METHOD_SUMMARY         "This method composes self, which must be a 3D affine transformation, with a clockwise rotation around a specified axis. The rotation angle is in radians; the axis of rotation goes through the origin. The rotation is postcomposed.")
    SET(MANAGED_METHOD_RETURN_TYPE     "void")
    SET(MANAGED_METHOD_PARAMS          "itkVector^ axis, double angle")
    SET(MANAGED_METHOD_TYPE_BODY       "this->Rotate3D( axis, angle, false );")
    SET(MANAGED_METHOD_WRAPPER_BODY    "iInstance->Rotate3D( axis, angle, false );")
  END_MANAGED_METHOD()

  BEGIN_MANAGED_METHOD("Shear")
    SET(MANAGED_METHOD_SUMMARY         "This method composes self with a shear transformation, replacing the original contents of self. The shear is precomposed with self if pre is true, and postcomposed otherwise.")
    SET(MANAGED_METHOD_RETURN_TYPE     "void")
    SET(MANAGED_METHOD_PARAMS          "int axis1, int axis2, double coef, bool pre")
    SET(MANAGED_METHOD_TYPE_BODY       "m_PointerToNative->Shear( axis1, axis2, static_cast<ScalarType>(coef), pre );")
    SET(MANAGED_METHOD_WRAPPER_BODY    "iInstance->Shear( axis1, axis2, coef, pre );")
  END_MANAGED_METHOD()
  
  BEGIN_MANAGED_METHOD("Shear")
    SET(MANAGED_METHOD_SUMMARY         "This method composes self with a shear transformation, replacing the original contents of self. The shear is postcomposed.")
    SET(MANAGED_METHOD_RETURN_TYPE     "void")
    SET(MANAGED_METHOD_PARAMS          "int axis1, int axis2, double coef")
    SET(MANAGED_METHOD_TYPE_BODY       "this->Shear( axis1, axis2, coef, false );")
    SET(MANAGED_METHOD_WRAPPER_BODY    "iInstance->Shear( axis1, axis2, coef, false );")
  END_MANAGED_METHOD()

END_WRAP_CLASS()
